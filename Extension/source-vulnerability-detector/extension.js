const vscode = require('vscode');
const detectSQLI = require('./rules/no_sqli');
const detectVULN = require('./rules/other_rules');

// Diagnostic Collection
const diagnosticCollection = vscode.languages.createDiagnosticCollection('vulnerabilities');

function activate(context) {
    console.log('Congratulations, SourceLint extension is now active!');

    // Register manual scan command
    context.subscriptions.push(
        vscode.commands.registerCommand('extension.scanCode', async function () {
            const editor = vscode.window.activeTextEditor;
            if (editor) {
                const document = editor.document;
                scanDocument(document);
            }
        })
    );

    // Register event to scan code on document save
    context.subscriptions.push(vscode.workspace.onDidSaveTextDocument((document) => {
        scanDocument(document);
    }));

    // Register a code actions provider for ignoring warnings
    context.subscriptions.push(vscode.languages.registerCodeActionsProvider({ language: 'javascript' }, new IgnoreWarningProvider(), {
        providedCodeActionKinds: IgnoreWarningProvider.providedCodeActionKinds
    }));

    // Register command to handle ignoring warnings
    context.subscriptions.push(vscode.commands.registerCommand('extension.ignoreWarning', (document, diagnostic) => {
        let diagnostics = diagnosticCollection.get(document.uri) || [];
        let updatedDiagnostics = diagnostics.filter(d => d !== diagnostic);
        diagnosticCollection.set(document.uri, updatedDiagnostics);
    }));
}

function scanDocument(document) {
    const text = document.getText();
    displayVulnerabilities(document, text);
}

async function displayVulnerabilities(document, text) {
    const sqliVulnerabilities = await detectSQLI(text);
    //const xssVulnerabilities = await detectXSS(text);
    const otherVulnerabilities = await detectVULN(text);

    const allVulnerabilities = {
        'SQL Injection Found': sqliVulnerabilities,
        'Vulnerability Found': otherVulnerabilities
    };

    displayVulnerabilityWarnings(document, allVulnerabilities);
}

function displayVulnerabilityWarnings(document, allvulnerabilities) {
    const diagnosticEntries = [];
    const decorationsArray = [];

    for (const [maincategory, matches] of Object.entries(allvulnerabilities)) {
        if (matches && matches.length > 0) {
            matches.forEach(match => {
                const message = `âš ï¸${maincategory}\n \nType: ${match.type}\nRecommendation:ðŸ’¡ \n-${match.recommendation}\n\n`;
                const range = new vscode.Range(match.lineNumber - 1, 0, match.lineNumber - 1, match.vulnerableCode.length);
                const diagnostic = new vscode.Diagnostic(range, message, vscode.DiagnosticSeverity.Warning);
                diagnostic.source = 'SourceLint';
                diagnostic.code = `${match.type}-${match.lineNumber}`;
                diagnosticEntries.push(diagnostic);

                decorationsArray.push({ range: range });
            });
        }
    }

    diagnosticCollection.set(document.uri, diagnosticEntries);

}

class IgnoreWarningProvider {
    static providedCodeActionKinds = [
        vscode.CodeActionKind.QuickFix
    ];

    provideCodeActions(document, range, context, token) {
        return context.diagnostics
            .filter(diagnostic => diagnostic.source === 'SourceLint')
            .map(diagnostic => this.createIgnoreWarningCommand(document, diagnostic));
    }

    createIgnoreWarningCommand(document, diagnostic) {
        const ignoreWarningAction = new vscode.CodeAction(`Ignore ${diagnostic.code}`, vscode.CodeActionKind.QuickFix);
        ignoreWarningAction.command = { title: 'Ignore Warning', command: 'extension.ignoreWarning', arguments: [document, diagnostic] };
        ignoreWarningAction.diagnostics = [diagnostic];
        return ignoreWarningAction;
    }
}

function deactivate() {
    diagnosticCollection.dispose();
}

module.exports = {
    activate,
    deactivate
};
