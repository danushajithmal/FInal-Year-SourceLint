const vscode = require('vscode');
const crypto = require('crypto');
const detectSQLI = require('./rules/no_sqli');
const detectVariables = require('./rules/variable_rule');
const detectFileUploads = require('./rules/file_upload_rule');
const detectEmailHeaders = require('./rules/email_header_rule');
const detectCSRFTokens = require('./rules/api_token_rule');
const { detectDynamicXSSVulnerabilities } = require('./rules/no_xss');

// Diagnostic Collection
const diagnosticCollection = vscode.languages.createDiagnosticCollection('vulnerabilities');

// Helper function to generate unique diagnostic codes
function generateDiagnosticCode(text, type) {
    // Create an MD5 hash based on the text and type, then truncate it to 5 characters
    const hash = crypto.createHash('md5').update(text + type).digest('hex');
    return hash.substring(0, 5); // Extract the first 5 characters
}

class IgnoreWarningProvider {
    static providedCodeActionKinds = [
        vscode.CodeActionKind.QuickFix
    ];

    constructor(context) {
        this.context = context;
    }

    provideCodeActions(document, range, context, token) {
        return context.diagnostics
            .filter(diagnostic => diagnostic.source === 'SourceLint')
            .map(diagnostic => this.createIgnoreWarningCommand(document, diagnostic));
    }

    createIgnoreWarningCommand(document, diagnostic) {
        const ignoreWarningAction = new vscode.CodeAction(`Ignore ${diagnostic.code}`, vscode.CodeActionKind.QuickFix);
        ignoreWarningAction.command = {
            title: 'Ignore Warning',
            command: 'extension.ignoreWarning',
            arguments: [document, diagnostic]
        };
        ignoreWarningAction.diagnostics = [diagnostic];
        return ignoreWarningAction;
    }

    async ignoreWarning(document, diagnostic) {
        const editor = vscode.window.activeTextEditor;
        if (editor && editor.document.uri.toString() === document.uri.toString()) {
            const ignoreComment = `// Ignored Warning: ${diagnostic.code}`;
            const firstLine = document.lineAt(0);
            const edit = new vscode.WorkspaceEdit();
            if (firstLine.text.startsWith("// Ignored Warning:")) {
                edit.insert(document.uri, firstLine.range.end, `\n${ignoreComment}`);
            } else {
                edit.insert(document.uri, firstLine.range.start, `${ignoreComment}\n`);
            }
            await vscode.workspace.applyEdit(edit);
        }

        let diagnostics = diagnosticCollection.get(document.uri) || [];
        let updatedDiagnostics = diagnostics.filter(d => d.code !== diagnostic.code);
        diagnosticCollection.set(document.uri, updatedDiagnostics);
    }
}

function activate(context) {
    console.log('Congratulations, SourceLint extension is now active!');

    // Instantiate IgnoreWarningProvider with context
    const ignoreWarningProvider = new IgnoreWarningProvider(context);

    // Register manual scan command
    context.subscriptions.push(
        vscode.commands.registerCommand('extension.scanCode', async function () {
            const editor = vscode.window.activeTextEditor;
            if (editor) {
                const document = editor.document;
                scanDocument(document);
            }
        })
    );

    // Register event to scan code on document save
    context.subscriptions.push(vscode.workspace.onDidSaveTextDocument((document) => {
        scanDocument(document);
    }));

    // Register a code actions provider for ignoring warnings
    context.subscriptions.push(vscode.languages.registerCodeActionsProvider({ language: 'javascript' }, ignoreWarningProvider, {
        providedCodeActionKinds: IgnoreWarningProvider.providedCodeActionKinds
    }));

    // Register command to handle ignoring warnings
    context.subscriptions.push(vscode.commands.registerCommand('extension.ignoreWarning', (document, diagnostic) => {
        ignoreWarningProvider.ignoreWarning(document, diagnostic);
    }));
}

function scanDocument(document) {
    const text = document.getText();
    const ignoredCodes = extractIgnoredCodes(text);
    displayVulnerabilities(document, text, ignoredCodes);
}

function extractIgnoredCodes(text) {
    const lines = text.split('\n');
    const ignoredCodes = [];
    for (const line of lines) {
        if (line.trim().startsWith('// Ignored Warning:')) {
            const code = line.split('// Ignored Warning:')[1].trim();
            ignoredCodes.push(code);
        } else if (!line.trim().startsWith('//')) {
            break; // Stop reading if a line does not start with a comment
        }
    }
    return ignoredCodes;
}

async function displayVulnerabilities(document, text, ignoredCodes) {
    const sqliVulnerabilities = await detectSQLI(text);
    const xssVulnerabilities = await detectDynamicXSSVulnerabilities(text);
    const otherVulnerabilities = await detectVariables(text);
    const fileUploadVulnerabilities = await detectFileUploads(text);
    const emailHeaderVulnerabilities = await detectEmailHeaders(text);
    const apiCSRFTokenVulnerabilities = await detectCSRFTokens(text);

    const allVulnerabilities = {
        'SQL Injection Found': sqliVulnerabilities,
        'Cross Site Scripting Found': xssVulnerabilities,
        'Unsafe User Input Found': otherVulnerabilities,
        'File upload Vulnerability Found': fileUploadVulnerabilities,
        'Email Header Vulnerability Found': emailHeaderVulnerabilities,
        'Missing CSRF Token Vulnerability Found': apiCSRFTokenVulnerabilities,
    };

    displayVulnerabilityWarnings(document, allVulnerabilities, ignoredCodes);
}

function displayVulnerabilityWarnings(document, allVulnerabilities, ignoredCodes) {
    const diagnosticEntries = [];

    for (const [maincategory, matches] of Object.entries(allVulnerabilities)) {
        if (matches && matches.length > 0) {
            matches.forEach(match => {
                const code = generateDiagnosticCode(match.vulnerableCode, match.type);
                if (!ignoredCodes.includes(code)) {
                    const message = `‚ö†Ô∏è${maincategory}\n\nType: ${match.type}\nRecommendation:üí°\n-${match.recommendation}\n\n`;
                    const range = new vscode.Range(match.lineNumber - 1, 0, match.lineNumber - 1, match.vulnerableCode.length);
                    const diagnostic = new vscode.Diagnostic(range, message, vscode.DiagnosticSeverity.Warning);
                    diagnostic.source = 'SourceLint';
                    diagnostic.code = code;
                    diagnosticEntries.push(diagnostic);
                }
            });
        }
    }

    diagnosticCollection.set(document.uri, diagnosticEntries);
}

function deactivate() {
    diagnosticCollection.dispose();
}

module.exports = {
    activate,
    deactivate
};
