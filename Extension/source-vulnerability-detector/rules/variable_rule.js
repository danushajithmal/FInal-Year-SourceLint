const { detectXSSVulnerabilities } = require('./no_xss');
const detectEmailHeaderVulnerabilities = require('./other');

module.exports = async function variableRule(codespace) {
    // Remove comments from the entire codespace before processing
    const cleanedCodespace = removeComments(codespace);

    // Use the cleaned `codespace` string directly
    const variableDeclarations = {};
    const functions = {};

    // Extract all functions using a global regex pattern that captures across multiple lines
    const functionRegex = /function\s+(\w+)\s*\(([^)]*)\)\s*\{([\s\S]*?)\}/g;
    let functionMatch;

    // First pass: Identify all functions and their sanitization status
    while ((functionMatch = functionRegex.exec(cleanedCodespace)) !== null) {
        const [_, funcName, params, body] = functionMatch;
        functions[funcName] = {
            parameters: params.split(',').map(p => p.trim()),
            body,
            isSanitizer: isSanitizationFunction(body),
            line: getLineNumber(cleanedCodespace, functionMatch.index)
        };
    }

    // Second pass: Identify variable declarations that use functions
    const variableRegex = /(const|let|var)\s+(\w+)\s*=\s*(.*?)(;|$)/g;
    let declarationMatch;
    while ((declarationMatch = variableRegex.exec(cleanedCodespace)) !== null) {
        const [_, declType, varName, varValue] = declarationMatch;
        const isSanitizedDirectly = /DOMPurify\.sanitize\(|encodeURIComponent\(|encodeURI\(/.test(varValue);

        if (!isSanitizedDirectly) {
            let functionCallMatch = /\b(\w+)\(([^)]+)\)/.exec(varValue);
            if (functionCallMatch) {
                let [fullMatch, funcName, params] = functionCallMatch;
                if (!(funcName in functions && functions[funcName].isSanitizer)) {
                    variableDeclarations[varName] = {
                        line: getLineNumber(cleanedCodespace, declarationMatch.index),
                        code: declarationMatch[0],
                    };
                }
            } else {
                variableDeclarations[varName] = {
                    line: getLineNumber(cleanedCodespace, declarationMatch.index),
                    code: declarationMatch[0]
                };
            }
        }
    }

    // Final vulnerabilities check
    const xssVulnerabilities = await detectXSSVulnerabilities(cleanedCodespace, variableDeclarations);
    return [...xssVulnerabilities];
};

// Utility Functions...

function getLineNumber(text, index) {
    return text.substring(0, index).split('\n').length;
}

function removeComments(body) {
    return body.replace(/\/\/[^\n]*|\/\*[\s\S]*?\*\//g, '');
}

// Function to analyze a code line for function sanitization patterns
function isSanitizationFunction(body) {
    const hasEscaping = /replace\(/.test(body) &&
        /\\['"<>]/.test(body);
    const hasWhitelisting = /test\(/.test(body) ||
        /match\(/.test(body) &&
        /\[[^\]]+\]/.test(body);
    const hasDangerousContentRemoval = /replace\(/.test(body) &&
        /(script|<|>|javascript:|eval\()/i.test(body);
    const hasCSSWhitelisting = /split\(\s*['"];\s*['"]\s*\)/.test(body) &&
        /forEach\s*\(/.test(body) &&
        /includes\s*\(/.test(body);

    return hasEscaping || hasWhitelisting || hasDangerousContentRemoval || hasCSSWhitelisting;
}

