const detectEmailHeaderVulnerabilities = require('./other');

module.exports = async function emailInputRule(codespace) {
    // Remove all comments before processing
    const cleanedCodespace = removeComments(codespace);
    const variableDeclarations = {};
    const functions = {};

    // Extract all functions using a global regex pattern that captures across multiple lines
    const functionRegex = /function\s+(\w+)\s*\(([^)]*)\)\s*\{([\s\S]*?)\}/g;
    let functionMatch;

    // First pass: Identify all functions and their sanitization status
    while ((functionMatch = functionRegex.exec(cleanedCodespace)) !== null) {
        const [_, funcName, params, body] = functionMatch;
        functions[funcName] = {
            parameters: params.split(',').map(p => p.trim()),
            body,
            isSanitizer: isSanitizationFunction(body),
            line: getLineNumber(cleanedCodespace, functionMatch.index)
        };
    }

    // Second pass: Identify variable declarations that use functions, including email headers
    const variableRegex = /(const|let|var)\s+(\w+)\s*=\s*({[\s\S]*?}|[^\n;]+)(;|$)/g;
    let declarationMatch;
    while ((declarationMatch = variableRegex.exec(cleanedCodespace)) !== null) {
        const [_, declType, varName, varValue] = declarationMatch;

        let functionCallMatch = /\b(\w+)\(([^)]+)\)/.exec(varValue);
        if (functionCallMatch) {
            let [fullMatch, funcName, params] = functionCallMatch;
            // Check if the function is a sanitizer
            if (!(funcName in functions && functions[funcName].isSanitizer)) {
                variableDeclarations[varName] = {
                    line: getLineNumber(cleanedCodespace, declarationMatch.index),
                    code: declarationMatch[0],
                };
            }
        } else if (/from|subject/i.test(varValue)) {
            // If not using any sanitization functions and includes common email header fields
            variableDeclarations[varName] = {
                line: getLineNumber(cleanedCodespace, declarationMatch.index),
                code: declarationMatch[0],
            };
        }
    }

    // Final vulnerabilities check (pass variableDeclarations to another module)
    const emailHeaderVulnerabilities = await detectEmailHeaderVulnerabilities(cleanedCodespace, variableDeclarations);
    return emailHeaderVulnerabilities;
};

// Utility Functions

// Function to remove single-line and multi-line comments
function removeComments(code) {
    return code.replace(/\/\/[^\n]*|\/\*[\s\S]*?\*\//g, '');
}

// Utility function to calculate the line number given an index
function getLineNumber(text, index) {
    return text.substring(0, index).split('\n').length;
}

// Function to analyze a code line for function sanitization patterns
function isSanitizationFunction(body) {
    const hasEncoding = /encodeURIComponent\(|escape\(/.test(body);
    const hasCharEscaping = body.includes('.replace(') && /['"<>\\]/.test(body);
    const hasLengthChecks = /\.length\s*[><]=?\s*\d+/.test(body);
    const hasWhitelisting = /new RegExp\(.+\)\.test\(/.test(body);
    const hasDangerousCharRemoval = /.replace\(/.test(body) && /[^A-Za-z0-9 ]/.test(body);
    const hasNewlineRemoval = /replace\(/.test(body) && /\\r\\n|\\n|\\r/.test(body);

    return hasEncoding || hasCharEscaping || hasLengthChecks || hasWhitelisting || hasDangerousCharRemoval || hasNewlineRemoval;
}
