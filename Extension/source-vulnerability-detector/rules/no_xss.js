//rule no_xss.js
module.exports = async function detectXSSVulnerabilities(text) {
    const lines = text.split('\n');
    const xssKeywords = [
        'innerHTML', 'document.write', 'eval', 'location', 'window.location', 'alert', 'confirm', 'prompt',
        'setTimeout', 'setInterval', 'document.URL', 'document.cookie', 'document.location', 'document.referrer',
        'unescape', 'encodeURIComponent', 'escape', 'encodeURI', 'RegExp',
        'Function', 'Function.constructor', 'Object.constructor', 'constructor.constructor',
        'document.getElementById', 'document.style.cssText'
    ];

    const keywordRegex = new RegExp('\\b(' + xssKeywords.join('|') + ')\\b', 'gi');

    let variableSanitizationStatus = {};
    const vulnerabilities = [];
    let inMultiLineComment = false;

    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
        const line = lines[lineNumber];

        if (line.includes('/*')) inMultiLineComment = true;
        if (line.includes('*/')) inMultiLineComment = false;
        if (inMultiLineComment || line.trim().startsWith('//') || line.trim().startsWith('#')) continue;

        const varAssignmentRegex = /var\s+(\w+)\s*=\s*(.*);/;
        const varMatch = line.match(varAssignmentRegex);
        if (varMatch) {
            const variable = varMatch[1];
            const value = varMatch[2];
            // Detect whether the variable assignment involves encoding
            if (/encodeURIComponent\(.+\)/.test(value) || /encodeURI\(.+\)/.test(value)) {
                variableSanitizationStatus[variable] = 'safe';
            } else {
                variableSanitizationStatus[variable] = 'unsafe';
            }
        }

        // Check for XSS vulnerabilities using keyword matching
        if (keywordRegex.test(line)) {
            const code = line.trim();
            try {
                const response = await checkXSSInjection(code, variableSanitizationStatus);
                if (response === 1) {
                    vulnerabilities.push({
                        code,
                        lineNumber: lineNumber + 1,
                    });
                }
            } catch (error) {
                console.error('Error checking for XSS vulnerability:', error);
            }
        }
    }

    return vulnerabilities;
}

async function checkXSSInjection(code, variableSanitizationStatus) {
    const Patterns = [
        /(\.innerHTML\s*=\s*|\.outerHTML\s*=\s*)([^'"`]+)/,
        /(eval\(|setTimeout\(|setInterval\(|new Function\()([^)]+)/,
        /document\.createElement\('script'\)\.src\s*=\s*([^;]+)/,
        /\.then\(\w+\s*=>\s*\w+\.innerHTML\s*=\s*\w+/,
        /document\.cookie\s*=.+\+/,
        /document\.write\(.+\+/,
        /eval\(\s*(\w+)\s*\);/,
        /(location.href\s*=\s*|window.open\(|location.replace\()(.*\+)/,
        /innerHTML\s*=\s*`[^`]*\${[^}]+}[^`]*`/,
        /document\.getElementById\(['"]\w+['"]\)\.(href|style\.cssText|innerHTML)\s*=\s*\w+;/,
    ];

    const safePatterns = [
        /\.textContent\s*=|\.appendChild\(document.createTextNode\(/,
        /encodeURIComponent\(|sanitizeHTML\(/,
        /DOMPurify\.sanitize\([^)]+\)/,
        /DOMPurify\.encodeURI\([^)]+\)/,

    ];

    for (const pattern of Patterns) {
        if (pattern.test(code)) {
            if (isUserInputValidated(code)) {
            }

            let isSafePatternFound = false;
            for (const safePattern of safePatterns) {
                if (safePattern.test(code)) {
                    isSafePatternFound = true;
                    break; 
                }
            }
            if (!isSafePatternFound) {
                const variableUsageRegex = /\b(\w+)\b/g;
                let match;
                while ((match = variableUsageRegex.exec(code)) !== null) {
                    const variable = match[1];
                    if (variableSanitizationStatus[variable] && variableSanitizationStatus[variable] === 'safe') {
                        return 0; 
                    }
                }
                return 1; 
            } else {
                return 0; 
            }
        }
    }

    return 0;
}


function isUserInputValidated(code) {
    const validationPatterns = [
        /sanitize\(\w+\)/, 
        /validate\(\w+\)/, 
        /encodeURI\(\w+\)/,
        /encodeURIComponent\(\w+\)/, 
        /escapeHtml\(\w+\)/,
        /Handlebars.escapeExpression\(\w+\)/, 
    ];

    const handlebarsAutomaticEscaping = /{{[^}]+}}/;

    if (code.includes('Handlebars') && handlebarsAutomaticEscaping.test(code)) {
        return true; 
    }

    for (const pattern of validationPatterns) {
        if (pattern.test(code)) {
            return true; 
        }
    }

    return false; 
}



