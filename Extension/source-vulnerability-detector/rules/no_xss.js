// rule no_xss.js
async function detectXSSVulnerabilities(codespace, variableDeclarations) {
    const lines = codespace.split('\n');
    const vulnerabilities = [];
    let inMultiLineComment = false;

    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
        const line = lines[lineNumber].trim();

        if (line.includes('/*')) inMultiLineComment = true;
        if (line.includes('*/')) inMultiLineComment = false;
        if (inMultiLineComment || line.startsWith('//')) continue;

        // Check each variable against the line for potential XSS patterns
        Object.keys(variableDeclarations).forEach(async varName => {
            const response = await checkXSSInjection(line, varName);
            if (response) {
                vulnerabilities.push({
                    type: response.type,
                    recommendation: response.recommendation,
                    vulnerableCode: line,
                    lineNumber: lineNumber + 1,
                    variableName: varName
                });
            }
        });
    }

    return vulnerabilities;
}

async function checkXSSInjection(line,varName) {
    const xssPatterns = [
        {
            pattern: new RegExp(`document\\.getElementById\\(['"]?\\w+['"]?\\)\\.innerHTML\\s*=\\s*(${varName});`, 'i'),
            type: "Unsafe Variable in innerHTML",
            recommendation: "Sanitize variables or use DOMPurify before assigning to innerHTML to prevent XSS."
        },
        {
            pattern: new RegExp(`\\w+\\.innerHTML\\s*=\\s*(${varName});`, 'i'),
            type: "Unsafe Variable in Dynamic innerHTML",
            recommendation: "Sanitize variables or use DOMPurify before innerHTML to prevent XSS."
        },
        {
            pattern: new RegExp(`document\\.getElementById\\(['"]?\\w+['"]?\\)\\.href\\s*=\\s*(${varName});`, 'i'),
            type: "Href Manipulation with Variable",
            recommendation: "Ensure URL inputs are properly sanitized or validated."
        },
        {
            pattern: new RegExp(`document\\.cookie\\s*=\\s*([^;]+)(${varName});`, 'i'),
            type: "Cookie Manipulation with Variable",
            recommendation: "Sanitize and validate user inputs before using them in cookies."
        },
        {
            pattern: new RegExp(`document\\.getElementById\\(['"]?\\w+['"]?\\)\\.style\\.cssText\\s*=\\s*(${varName});`, 'i'),
            type: "CSS Manipulation with Variable",
            recommendation: "Avoid direct CSS manipulations with user inputs; sanitize inputs for style properties."
        },
        {
            pattern: new RegExp(`eval\\((.*)(${varName})\\)`, 'i'),
            type: "Eval Usage with Variable",
            recommendation: "Avoid using eval() to prevent arbitrary code execution."
        },
        {
            pattern: new RegExp(`setTimeout\\((.*)(${varName}),\\s*0?\\)`, 'i'),
            type: "setTimeout with Variable",
            recommendation: "Use safe, indirect methods to set dynamic timers without directly executing code."
        },
        {
            pattern: new RegExp(`document\\.write\\((.*)(${varName})\\)`, 'i'),
            type: "Document.write Usage with Variable",
            recommendation: "Prefer DOM manipulation methods over document.write() to prevent dynamic code execution."
        },
        {
            pattern: new RegExp(`document\\.write\\(['"]?<div>['"]?\\s*\\+\\s*${varName}\\s*\\+\\s*['"]?</div>['"]?\\);`, 'i'),
            type: "Unsafe use of document.write with Variable",
            recommendation: "Avoid using document.write with user inputs to prevent XSS; sanitize inputs or use safer alternatives like textContent."
        }
    ];

    
    
    for (const { pattern, type, recommendation } of xssPatterns) {
        if (pattern.test(line)) {
            return { type, recommendation, vulnerableCode: line };
            
        }
    }

    return null; 
}

// Function to detect XSS vulnerabilities from dynamic sources
async function detectDynamicXSSVulnerabilities(codespace) {
    const lines = codespace.split('\n');
    const vulnerabilities = [];
    let inMultiLineComment = false;

    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
        const line = lines[lineNumber].trim();

        if (line.includes('/*')) inMultiLineComment = true;
        if (line.includes('*/')) inMultiLineComment = false;
        if (inMultiLineComment || line.startsWith('//')) continue;

        const xssPatterns = [
            {
                pattern: /document\.getElementById\(['"]?\w+['"]?\)\.innerHTML\s*=\s*([^;]+);/i,
                type: "Direct innerHTML Manipulation",
                recommendation: "Use textContent instead of innerHTML to avoid XSS risks."
            },
            {
                pattern: /\.innerHTML\s*=\s*.*\s*\+\s*[^;]+;/i,
                type: "Potential XSS via innerHTML with Concatenation",
                recommendation: "Use DOMPurify to sanitize data or use textContent."
            },
            
        ];

        xssPatterns.forEach(({ pattern, type, recommendation }) => {
            if (pattern.test(line) && !/DOMPurify\.sanitize|DOMPurify\.encodeURI|encodeURIComponent|encodeURI/.test(line)) {
                vulnerabilities.push({
                    type,
                    recommendation,
                    vulnerableCode: line,
                    lineNumber: lineNumber + 1
                });
            }
        });
    }

    return vulnerabilities;
}


module.exports = {
    detectXSSVulnerabilities,
    detectDynamicXSSVulnerabilities
};