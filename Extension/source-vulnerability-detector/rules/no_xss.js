//rule no_xss.js

module.exports = async function detectXSSVulnerabilities(text) {
    const lines = text.split('\n');
    const xssKeywords = [
        'innerHTML', 'document.write', 'eval', 'location', 'window.location', 'alert', 'confirm', 'prompt',
        'setTimeout', 'setInterval', 'document.URL', 'document.cookie', 'document.location', 'document.referrer',
        'unescape', 'encodeURIComponent', 'decodeURIComponent', 'escape', 'encodeURI', 'decodeURI', 'RegExp',
        'Function', 'Function.constructor', 'Object.constructor', 'constructor.constructor', 'constructor.constructor.constructor'
    ];

    const keywordRegex = new RegExp('\\b(' + xssKeywords.join('|') + ')\\b', 'gi');

    let variableSanitizationStatus = {};
    const vulnerabilities = [];
    let inMultiLineComment = false;

    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
        const line = lines[lineNumber];

        if (line.includes('/*')) inMultiLineComment = true;
        if (line.includes('*/')) inMultiLineComment = false;
        if (inMultiLineComment || line.trim().startsWith('//') || line.trim().startsWith('#')) continue;

        // Track variable assignments for sanitization or encoding
        const varAssignmentRegex = /var\s+(\w+)\s*=\s*(.*);/;
        const varMatch = line.match(varAssignmentRegex);
        if (varMatch) {
            const variable = varMatch[1];
            const value = varMatch[2];
            // Detect whether the variable assignment involves sanitization or encoding
            if (/encodeURIComponent\(.+\)/.test(value) || /sanitize\(.+\)/.test(value)) {
                variableSanitizationStatus[variable] = 'safe';
            } else {
                variableSanitizationStatus[variable] = 'unsafe';
            }
        }

        // Check for XSS vulnerabilities using keyword matching
        if (keywordRegex.test(line)) {
            const code = line.trim();
            try {
                const response = await checkXSSInjection(code, variableSanitizationStatus);
                if (response === 1) {
                    vulnerabilities.push({
                        code,
                        lineNumber: lineNumber + 1,
                    });
                }
            } catch (error) {
                console.error('Error checking for XSS vulnerability:', error);
            }
        }
    }

    return vulnerabilities;
}

async function checkXSSInjection(code, variableSanitizationStatus) {
    const Patterns = [
        // Direct assignment to innerHTML with potentially unsafe data
        /(\.innerHTML\s*=\s*|\.outerHTML\s*=\s*)([^'"`]+)/,
        // Use of eval() or similar dangerous methods with unstructured data
        /(eval\(|setTimeout\(|setInterval\(|new Function\()([^)]+)/,
        // Dynamic script creation with unsanitized inputs
        /document\.createElement\('script'\)\.src\s*=\s*([^;]+)/,
        // Unsafe insertion of data into the DOM via innerHTML due to AJAX responses
        /\.then\(\w+\s*=>\s*\w+\.innerHTML\s*=\s*\w+/,
        // Direct cookie manipulation with unsanitized user inputs
        /document\.cookie\s*=.+\+/,
        // Using user input directly in document.write
        /document\.write\(.+\+/,
        // Executing user input without validation
        /eval\(\s*(\w+)\s*\);/,
        // Insecurely setting URL-related properties with user input
        /(location.href\s*=\s*|window.open\(|location.replace\()(.*\+)/,
        // InnerHTML being set directly with template literals containing variables (potential user input)
        /innerHTML\s*=\s*`[^`]*\${[^}]+}[^`]*`/,

        /document\.getElementById\(['"]\w+['"]\)\.(href|style\.cssText|innerHTML)\s*=\s*\w+;/,
        /document\.getElementById\(['"]\w+['"]\)\.(href|style\.cssText|innerHTML)\s*=\s*.+[^;]/,   
    ];

    const safePatterns = [
        // Using textContent or creating text nodes are safer alternatives to innerHTML
        /\.textContent\s*=|\.appendChild\(document.createTextNode\(/,
        // Properly encoding or sanitizing user inputs before use
        /encodeURIComponent\(|sanitizeHTML\(/,
        /DOMPurify\.sanitize\([^)]+\)/,

    ];

    // Check for direct patterns of vulnerability
    for (const pattern of Patterns) {
        if (pattern.test(code)) {
            // Before concluding its vulnerability, check for input validation
            if (isUserInputValidated(code)) {
                return 0; // Input is considered validated/sanitized, thus safe
            }

            // Additional check against safePatterns to identify negated vulnerabilities
            let isSafePatternFound = false;
            for (const safePattern of safePatterns) {
                if (safePattern.test(code)) {
                    isSafePatternFound = true;
                    break; // Found a safe pattern, so this instance is not considered vulnerable
                }
            }
            if (!isSafePatternFound) {
                // If no direct validation/sanitization or safe patterns found, proceed to check variable usage
                const variableUsageRegex = /\b(\w+)\b/g;
                let match;
                while ((match = variableUsageRegex.exec(code)) !== null) {
                    const variable = match[1];
                    if (variableSanitizationStatus[variable] && variableSanitizationStatus[variable] === 'safe') {
                        return 0; // The use of the variable is considered safe
                    }
                }
                return 1; // Unsafe use of variable detected after all checks
            } else {
                return 0; // Safe pattern found, not vulnerable
            }
        }
    }

    return 0;
}


function isUserInputValidated(code) {
    const validationPatterns = [
        // Patterns that suggest input validation or sanitization
        /sanitize\(\w+\)/, // Generic sanitization function call
        /validate\(\w+\)/, // Generic validation function call
        /encodeURIComponent\(\w+\)/, // URL encoding
        /escapeHtml\(\w+\)/, // HTML escape function
        /Handlebars.escapeExpression\(\w+\)/, // Explicit Handlebars escaping
        // Add more patterns based on common validation/sanitization functions used in your projects
    ];

    // Special case for Handlebars automatic escaping in templates
    const handlebarsAutomaticEscaping = /{{[^}]+}}/;

    if (code.includes('Handlebars') && handlebarsAutomaticEscaping.test(code)) {
        // This is a simplification; real-world use might need to parse/interpret the template more deeply.
        return true; // Assume Handlebars templates are safe due to automatic escaping
    }

    for (const pattern of validationPatterns) {
        if (pattern.test(code)) {
            return true; // Input is validated or sanitized
        }
    }

    return false; // No evidence of input validation or sanitization
}



