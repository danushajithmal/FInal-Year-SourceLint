
module.exports = async function csrfRule(codespace) {
    // Preprocess to remove comments from the code space
    const cleanedCodespace = removeComments(codespace);

    // Regex to find CSRF middleware declaration
    const csrfMiddlewareRegex = /(const|let|var)\s+(\w+)\s*=\s*csrf\(/g;
    let csrfMiddlewareName = null;
    let middlewareMatch = csrfMiddlewareRegex.exec(cleanedCodespace);
    if (middlewareMatch) {
        csrfMiddlewareName = middlewareMatch[2]; // Capture the variable name
    }

    // Regex to identify API endpoints
    const apiRegex = /app\.(get|post|put|delete|patch)\(\s*['"`\/](.*?)['"`\/],\s*(?:async\s*)?\((req, res)\)\s*=>\s*\{([\s\S]*?)\}\s*\);/gm;
    let match;
    const potentialVulnerabilities = [];

    while ((match = apiRegex.exec(cleanedCodespace)) !== null) {
        const [_, method, path, handler] = match;

        // Check if CSRF protection middleware is used in this endpoint
        const csrfProtectionRegex = new RegExp(`\\b${csrfMiddlewareName}\\b`, 'i');
        const isProtected = csrfProtectionRegex.test(handler);

        if (!isProtected) {
            // Extract the first line of the vulnerable API endpoint
            const firstLine = handler.split('\n')[0].trim();

            potentialVulnerabilities.push({
                type: "CSRF Vulnerability",
                recommendation: "Include CSRF protection middleware to secure this endpoint.",
                vulnerableCode: `app.${method}('${path}', ${firstLine})`,
                lineNumber: getLineNumber(cleanedCodespace, match.index)
            });
        }
    }

    // Log the vulnerabilities found
    console.log(potentialVulnerabilities);
    return potentialVulnerabilities;
};

// Function to remove single-line and multi-line comments
function removeComments(body) {
    return body.replace(/\/\/[^\n]*|\/\*[\s\S]*?\*\//g, '');
}

function getLineNumber(text, index) {
    return text.substring(0, index).split('\n').length;
}
