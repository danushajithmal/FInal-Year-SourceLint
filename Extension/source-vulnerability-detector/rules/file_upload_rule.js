const detectVulnerabilities = require('./other');

module.exports = async function analyzeFileUploads(codespace) {
    // Remove comments from the codespace before processing
    const cleanedCodespace = removeComments(codespace);
    const variableDeclarations = {};

    // Regex to identify API endpoints
    const apiRegex = /app\.(get|post|put|delete|patch)\(\s*['"`\/](.*?)['"`\/],\s*(?:async\s*)?\((req, res)\)\s*=>\s*\{([\s\S]*?)\}\s*\);/gm;
    let match;

    // First pass: Extract all API handlers, clean comments, and track file-related variables
    while ((match = apiRegex.exec(cleanedCodespace)) !== null) {
        const [_, method, path, params, body] = match;
        const cleanedBody = removeComments(body);

        // Direct extraction of file-related variables
        const varRegex = /(let|var|const)\s+(\w+)\s*=\s*req\.files\.(\w+)/g;
        let varMatch;

        while ((varMatch = varRegex.exec(cleanedBody)) !== null) {
            const varName = varMatch[2]; // Capture the variable name
            const lineNumber = getLineNumber(cleanedCodespace, varMatch.index);

            // Check if the variable is sanitized
            const isSanitized = isVariableSanitized(cleanedBody, varName);

            // Only add variables to declarations if not sanitized
            if (!isSanitized) {
                variableDeclarations[varName] = {
                    line: lineNumber,
                    code: varMatch[0]
                };
            }
        }
    }

    // Pass the variableDeclarations to another module for final analysis
    const vulnerabilities = await detectVulnerabilities(cleanedCodespace, variableDeclarations);
    return vulnerabilities;
};

// Utility functions
function removeComments(body) {
    // Remove both single-line and multi-line comments
    return body.replace(/\/\/[^\n]*|\/\*[\s\S]*?\*\//g, '');
}

function getLineNumber(text, index) {
    // Calculate line number given an index in the text
    return text.substring(0, index).split('\n').length;
}

function isVariableSanitized(body, varName) {
    // File extension related regex
    const extensionExtractionRegex = new RegExp(
        `\\bpath\\.extname\\(\\s*${varName}\\.name\\s*\\)\\.toLowerCase\\(\\)`,
        'i'
    );
    const extensionArrayDeclarationRegex = new RegExp(
        `\\b(?:const|let|var)\\s+\\w+\\s*=\\s*\\[\\s*(?:['"](\\.jpg|\\.jpeg|\\.png|\\.gif|\\.pdf|\\.docx|\\.xlsx|\\.svg)['"]\\s*,?\\s*)+\\s*\\]`,
        'i'
    );

    // File size related regex
    const fileSizeCheckRegex = new RegExp(
        `\\bif\\s*\\(\\s*${varName}\\.size\\s*([<>]=?|==|!=)\\s*(?:\\d+(?:\\s*\\*\\s*\\d+)?|\\w+)\\s*\\)`,
        'i'
    );

    // MIME type related regex
    const mimeArrayDeclarationRegex = new RegExp(
        `\\b(?:const|let|var)\\s+\\w+\\s*=\\s*\\[\\s*['"](image\\/jpeg|image\\/png|application\\/pdf|audio\\/mpeg|text\\/html|video\\/mp4|application\\/json)['"](\\s*,\\s*['"](image\\/jpeg|image\\/png|application\\/pdf|audio\\/mpeg|text\\/html|video\\/mp4|application\\/json)['"])*\\s*\\]`,
        'i'
    );
    const mimeCheckRegex = new RegExp(
        `if\\s*\\(!\\s*\\w+\\.includes\\(\\s*${varName}\\.mimetype\\s*\\)\\s*\\)`,
        'i'
    );

    // Regex to check if the file is moved (using the file variable)
    const moveOperationRegex = new RegExp(
        `${varName}\\.mv\\(`,
        'i'
    );

    const extensionExtracted = extensionExtractionRegex.test(body);
    const extensionChecked = extensionArrayDeclarationRegex.test(body);
    const fileSizeChecked = fileSizeCheckRegex.test(body);
    const mimeArrayChecked = mimeArrayDeclarationRegex.test(body);
    const mimeChecked = mimeCheckRegex.test(body);
    const fileMovedmv = moveOperationRegex.test(body);

    return (extensionExtracted || extensionChecked) && fileMovedmv ||
           (mimeArrayChecked || mimeChecked) && fileMovedmv ||
           fileSizeChecked && fileMovedmv;
}
