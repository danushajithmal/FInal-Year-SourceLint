// other_rules.js
module.exports = async function detectOtherVulnerabilities(codespace, variableDeclarations) {
    const lines = codespace.split('\n');
    const vulnerabilities = [];
    let inMultiLineComment = false;

    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
        const line = lines[lineNumber].trim();

        if (line.includes('/*')) inMultiLineComment = true;
        if (line.includes('*/')) inMultiLineComment = false;
        if (inMultiLineComment || line.startsWith('//')) continue;

        // Check each variable against the line for potential file upload vulnerabilities
        Object.keys(variableDeclarations).forEach(async varName => {
            const response = await fileUploadVulnerabilities(line, varName);
            if (response) {
                vulnerabilities.push({
                    type: response.type,
                    recommendation: response.recommendation,
                    vulnerableCode: line,
                    lineNumber: lineNumber + 1,
                    variableName: varName
                });
            }
        });
    }

    return vulnerabilities;
}

async function fileUploadVulnerabilities(line, varName) {
    console.log(varName);
    const patterns = [
        {
            pattern: new RegExp(`${varName}\\.mv\\(`, 'i'),
            type: "Direct File Upload without Validation",
            recommendation: "Validate file types and check for file extensions before saving files to the server."
        },
    ];

    for (const { pattern, type, recommendation } of patterns) {
        if (pattern.test(line)) {
            return { type, recommendation, vulnerableCode: line };
        }
    }

    return null; 
}

