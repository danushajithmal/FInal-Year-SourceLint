//rules.js

module.exports = async function detectVulnerabilities(text) {
    const lines = text.split('\n');
    const Keywords = [
        //keywords to identify code segemnts
    ];

    const keywordRegex = new RegExp('\\b(' + Keywords.join('|') + ')\\b', 'gi');

    const vulnerabilities = [];

    let inMultiLineComment = false;

    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
        const line = lines[lineNumber];
        
        // Check for the start of a multi-line comment (/*)
        if (line.includes('/*')) {
            inMultiLineComment = true;
        }
        
        // Check for the end of a multi-line comment (*/)
        if (line.includes('*/')) {
            inMultiLineComment = false;
        }
        
        // Skip lines that are entirely within a multi-line comment
        if (inMultiLineComment) {
            continue;
        }
        
        // Check for single-line comments in JavaScript, JSX, and Python
        if (line.trim().startsWith('//') || line.trim().startsWith('#')) {
            continue;
        }

        if (keywordRegex.test(line.toUpperCase())) {
            const code = line.trim();
            try {
                const response = await check(code);
                if (response === 1) {
                    vulnerabilities.push({
                        code,
                        lineNumber: lineNumber + 1,
                    });
                }
            } catch (error) {
                console.error('Error in checking :', error);
            }
        }
    }

    return vulnerabilities;
}

//Check the selected code for vulnerability by pattern matching
async function check(code) {
    
    //Mechanism of checking for vulneability
    return 0
}


