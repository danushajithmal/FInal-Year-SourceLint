//rule no_sqli.js

const axios = require('axios');

module.exports = async function detectAndCheckSQLInjection(text) {
    const lines = text.split('\n');
    const sqlKeywords = [
        'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'FROM', 'WHERE',
        'UNION', 'DROP', 'EXEC', ';', '--', '\\|\\|', "'", '"', '%',
        '\\/\\*', '\\*\\/'
    ];

    const keywordRegex = new RegExp('\\b(' + sqlKeywords.join('|') + ')\\b', 'gi');

    const vulnerabilities = [];

    let inMultiLineComment = false;

    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
        const line = lines[lineNumber];
        
        // Check for the start of a multi-line comment (/*)
        if (line.includes('/*')) {
            inMultiLineComment = true;
        }
        
        // Check for the end of a multi-line comment (*/)
        if (line.includes('*/')) {
            inMultiLineComment = false;
        }
        
        // Skip lines that are entirely within a multi-line comment
        if (inMultiLineComment) {
            continue;
        }
        
        // Check for single-line comments in JavaScript, JSX, and Python
        if (line.trim().startsWith('//') || line.trim().startsWith('#')) {
            continue;
        }

        if (keywordRegex.test(line.toUpperCase())) {
            const query = line.trim();
            try {
                const response = await checkSQLInjection(query);
                if (response === 1) {
                    vulnerabilities.push({
                        query,
                        lineNumber: lineNumber + 1,
                    });
                }
            } catch (error) {
                console.error('Error checking SQL injection:', error);
            }
        }
    }

    return vulnerabilities;
}

async function checkSQLInjection(query) {
    // List of SQL injection patterns to check for
    const sqliPatterns = [
        /(\bUNION\s+SELECT\b)/i, // UNION SELECT
        /(\bINSERT\s+INTO\b)/i, // INSERT INTO
        /(\bDELETE\s+FROM\b)/i, // DELETE FROM
        /(\bUPDATE\s+SET\b)/i, // UPDATE SET
        /(\bDROP\s+TABLE\b)/i, // DROP TABLE
        /(\bSELECT\s+.*?\bFROM\b)/i, // SELECT ... FROM (match until the next FROM)
        /(\bWHERE\s+.*?\s*=\s*'.*?'\s*(?:OR|AND)\s+.*?\s*=\s*'.*?')/i, // WHERE ... = '...' (OR/AND) ... = '...'
        /(['"`=]+\s*\+\s*['"`])/, // Concatenated strings (' + ' or " + ")
    ];

    // Non-vulnerable patterns to exclude
    const nonVulnerablePatterns = [
        /(\bINSERT\s+INTO\b\s*\([^)]*\)\s*VALUES\s*\([^)]*\)\s*;?)/i, // INSERT INTO ... VALUES ...
        /(\bSELECT\s+\*\s+FROM\b\s*\([^)]*\)\s*;?)/i, // SELECT * FROM ... (subquery)
        /(\?\s*(?:, \?)*\s*;?)/, // Parameterized placeholders (?, ?, ...)
        /(\bSELECT\s+.*?\s+FROM\s+.*?\s+WHERE\s+.*?\s+=\s+'.*?'\s+AND\s+.*?\s+=\s+'.*?')/i, // SELECT ... FROM ... WHERE ... = '...' AND ... = '...'
        /(\bSELECT\s+.*?\s+FROM\s+.*?\s+WHERE\s+.*?\s+=\s+".*?"\s+AND\s+.*?\s+=\s+".*?")/i, // SELECT ... FROM ... WHERE ... = "..." AND ... = "..."
        /(\bSELECT\s+.*?\s+FROM\s+.*?\s+WHERE\s+.*?\s+=\s+'.*?'\s+ORDER\s+BY\s+.*?)/i, // SELECT ... FROM ... WHERE ... = '...' ORDER BY ...
    ];

    // Check if the query contains a semicolon followed by DROP TABLE
    if (/\;\s*DROP\s+TABLE\b/i.test(query)) {
        return 1; // Return 1 to indicate vulnerability
    }

    // Check if the query matches any non-vulnerable pattern
    for (const pattern of nonVulnerablePatterns) {
        if (pattern.test(query)) {
            return 0; // Return 0 to indicate non-vulnerability
        }
    }

    // Check if the query matches any vulnerable pattern
    for (const pattern of sqliPatterns) {
        if (pattern.test(query)) {
            return 1; // Return 1 to indicate vulnerability
        }
    }

    // If none of the SQL injection patterns are found, return 0 indicating no vulnerability
    return 0;
}
