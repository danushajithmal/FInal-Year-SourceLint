//rule no_sqli.js
module.exports = async function detectAndCheckSQLInjection(text) {
    const lines = text.split('\n');
    const sqlKeywords = [
        'SELECT', 'INSERT', 'UPDATE', 'DELETE', 'FROM', 'WHERE',
        'UNION', 'DROP', 'EXEC', ';', '--', '\\|\\|', "'", '"', '%',
        '\\/\\*', '\\*\\/'
    ];

    const keywordRegex = new RegExp('\\b(' + sqlKeywords.join('|') + ')\\b', 'gi');

    const vulnerabilities = [];

    let inMultiLineComment = false;

    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
        const line = lines[lineNumber];
        
        // Check for the start of a multi-line comment (/*)
        if (line.includes('/*')) {
            inMultiLineComment = true;
        }
        
        // Check for the end of a multi-line comment (*/)
        if (line.includes('*/')) {
            inMultiLineComment = false;
        }
        
        // Skip lines that are entirely within a multi-line comment
        if (inMultiLineComment) {
            continue;
        }
        
        // Check for single-line comments in JavaScript, JSX, and Python
        if (line.trim().startsWith('//') || line.trim().startsWith('#')) {
            continue;
        }

        if (keywordRegex.test(line.toUpperCase())) {
            const query = line.trim();
            try {
                const response = await checkSQLInjection(query);
                if (response === 1) {
                    vulnerabilities.push({
                        query,
                        lineNumber: lineNumber + 1,
                    });
                }
            } catch (error) {
                console.error('Error checking SQL injection:', error);
            }
        }
    }

    return vulnerabilities;
}

async function checkSQLInjection(query) {
    
    const sqliPatterns = [
        // Basic Injection
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?(?:\bOR\b|\bAND\b)\s*('[^']*'|[0-9]+)\s*;?)(?!\s*['":])(?!\s*'\w+')/i,
    
        // Union Based Injection
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?\bUNION\b\s+SELECT\b)/i,
    
        // Error Based Injection
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?\b=\b[0-9]+\b(?:\s*OR\b\s*1=1)?)/i,
    
        // Time Based Injection
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?\bIF\b\s*\([^)]*\)\s*\bSLEEP\b\s*\([^)]*\))/i,
    
        // Concatenation Injection
        /(\bINSERT\s+INTO\s+\w+\s*\([^)]*\)\s*VALUES\s*\(\s*'[^']*'\s*,\s*'[^']*'\s*\)\s*;?)/i,
        /(\bINSERT\s+INTO\s+\w+\s*\([^)]*\)\s*VALUES\s*\(\s*\$\{[^}]*\}\s*,\s*\$\{[^}]*\}\s*\)\s*;?)/i,
    
        // Dynamic Query Construction
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?\b=\b\s*('\$\w+'\s*|[^'";\n]+)\s*;?)/i,
    
        // Injection via string interpolation
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?\b=\b\s*`[^`]*`\s*;?)/i,
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?\b=\b\s*"([^"]|\\")*"\s*;?)/i,
    
        // Injection via template literals
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?\b=\b\s*`[^`]*`\s*;?)/i,
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?\b=\b\s*\${[^}]*}\s*;?)/i,
    
        // Injection via direct concatenation
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?\b=\b\s*`?[^`]*`?\s*;?)/i, // Detects direct concatenation with backticks
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?\b=\b\s*'.*'\s*;?)/i, // Detects direct concatenation with single quotes
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?\b=\b\s*\$\{[^}]*\}\s*;?)/i, // Detects direct concatenation with ${} syntax
        /(\bBETWEEN\s+\$\{\w+\})/i, // Detects variables concatenated in BETWEEN clause
        /(\bAND\s+\$\{\w+\})/i, // Detects variables concatenated in AND clause
        /(\bSELECT\s+.*?\bFROM\b\s+.*?\bWHERE\b\s+.*?\b=\s*\${[^};]*};?)/i,
    
        /(\bWAITFOR\s+DELAY\s+'\d{2}:\d{2}:\d{2}'\s*;?)/i,
        /(\bIF\s*\([^)]*\)\s*WAITFOR\s+DELAY\s+'\d{2}:\d{2}:\d{2}'\s*;?)/i,
        /(\bSLEEP\s*\(\s*\d+\s*\)\s*;?)/i,
        /(\bBENCHMARK\s*\(\s*\d+\s*,\s*MD5\('A'\)\s*\)\s*;?)/i,
        /(\bAND\s+1=(?:0|1)\s*;?)/i,
        /(\bOR\s+1=(?:0|1)\s*;?)/i,
        /(\bUNION\s+SELECT\b)/i,
        /(\bDROP\s+TABLE\b)/i,
        /(\bWAITFOR\s+DELAY\s+'\d{2}:\d{2}:\d{2}'\s*;?)/i,
        /(\bAND\s+\d+=\d+\s*--\s*\d+)/i,
    ];
    
    

    // Check if the query matches any vulnerable pattern
    for (const pattern of sqliPatterns) {
        if (pattern.test(query)) {
            return 1; // Return 1 to indicate vulnerability
        }
    }

    return 0;
}

